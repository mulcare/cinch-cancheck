# = Cinch 'cancheck' plugin
# Monitors channel for "#cancheck" hashtag, looks for an image url elsewhere
# in the message, then compresses, stores, and presents images on a website.
# While the need for this is probably small beyond my personal use, it could
# easily be adapted for a more general purpose #hastag image capture system.
#
# == Configuration
# Add the following to your bot's configure.do stanza:
#
#   config.plugins.options[Cinch::CanCheck] = {
#     :tinify_api_key => "",
#     :aws_access_key_id => "",
#     :aws_secret_access_key => "",
#     :aws_region => "",
#     :aws_path => "",
#     :cancheck_html_template => "",
#     :cancheck_html_ouput => "",
#     :cancheck_sqlite3_db => "",
#     :cancheck_public_url => ""
#   }
#
# [tinify_api_key]
#   Tinify is the API interface for tinypng, a service to compress jpg and png
#   images with minimal quality loss. API keys are available after signing up
#   for an account at https://tinypng.com/developers.
#
# [aws_access_key_id]
#   Amazon Web Services access credential. For information on how tinify uses
#   this and the following AWS information, see the tinify dev reference page:
#   https://tinypng.com/developers/reference#saving-to-amazon-s3
#
# [aws_secret_access_key]
#   AWS access credential. Remember: do not use global AWS keys. You should
#   generate an AWS keypair specifically for tinify and limit its access to
#   your s3 buckets and AWS account.
#
# [aws_region]
#   Region code where your bucket is hosted. Amazon provides a list of codes:
#   http://docs.aws.amazon.com/general/latest/gr/rande.html#apigateway_region
#
#     ex: us-east-1
#
# [aws_path]
#   Path to the bucket where tinified images will be stored. This will always
#   begin with the name of the bucket that you've given the tinify AWS user
#   access to, and may also include any subdirectories. Do not include leading
#   or trailing slashes (/)
#
#     ex: example-bucket/my-images
#
# [cancheck_html_template]
#   Should point to a ruby ERB html file that cycles through the @cans variable
#   generated by the plugin. See the included example.html.erb
#
#     ex: /var/www/index.html.erb
#
# [cancheck_html_output]
#   The output of the above ERB file. Generally this will be hosted in a
#   publicly-accessible directory.
#
#     ex: /var/www/html/index.html
#
# [cancheck_sqlite3_db]
#   Location of the database used to store #cancheck information. Requires a
#   table named 'cans'. Schema is as follows:
#
#     CREATE TABLE cans(
#       id integer PRIMARY KEY,
#       date varchar(255),
#       nick varchar(255),
#       image varchar(255)
#     );
#
# [cancheck_public_url]
#   Link to page that displays #canchecks. This will be the public-facing url
#   that points to the [cancheck_html_output] page.
#
#     ex: http://cancheck.com/canchecks/
#
# == Author
# Ross Mulcare (@mulcare)
#
# == Notes
# Thanks to Marvin G√ºlker (Quintus) for his numerous Cinch plugins that I have
# learned and borrowed from. The above comments/documentation are cribbed from
# his style. See: https://github.com/Quintus/cinch-plugins
#
# == License
# The MIT License (MIT)
# Copyright (c) 2016 Ross Mulcare
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

require 'erb'
require 'sqlite3'
require 'uri'
require 'tinify'


class Cinch::CanCheck
  include Cinch::Plugin
 
  #Custom errors for clean handling after a match
  class NoUrlError < StandardError; end
  class ExtError < StandardError; end

  listen_to :connect, :method => :setup

  def setup(*)
    @tinify_api_key = config[:tinify_api_key]
    
    @aws_access_key_id = config[:aws_access_key_id]
    @aws_secret_access_key = config[:aws_secret_access_key]
    @aws_region = config[:aws_region]
    @aws_path = config[:aws_path]

    @cancheck_html_template = config[:cancheck_html_template]
    @cancheck_html_output = config[:cancheck_html_output]
    @cancheck_sqlite3_db = config[:cancheck_sqlite3_db]
    @cancheck_public_url = config[:cancheck_public_url]
  end

  def format_filename(user, date, ext)
    @filename = user + "_" + date + ext
  end

  def tinify(source)
    begin
      Tinify.key = @tinify_api_key
      Tinify.validate!
      if Tinify.compression_count <= 500
        image = Tinify.from_url(source)
        @image_on_s3 = image.store(
          service: "s3",
          aws_access_key_id: @aws_access_key_id,
          aws_secret_access_key: @aws_secret_access_key,
          region: @aws_region,
          path: "#{@aws_path}/#{@filename}"
        )
      else
        return "over compression limit"
      end
    rescue Tinify::AccountError => e
      @bot.loggers.info "Problem with Tinify API key. Ensure :tinify_api_key in config is set and accurate."
    end
  end
    
  def detect_url(message)
    can_url = message.scan(/(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9]-?)*[a-z0-9]+)(?:\.(?:[a-z0-9]-?)*[a-z0-9]+)*(?:\.(?:[a-z]{2,})))(?::\d{2,5})?(?:\/\S*)?/)
    if can_url.empty?
      raise NoUrlError
    else
      @ext = File.extname(URI.parse(can_url[0]).path)
      if (@ext =~/^.(png|jpg)$/i)
        @can_url = can_url[0]
      else
        raise ExtError
      end
    end
  end

  def db_write(date, nick, image)
    @db = SQLite3::Database.open @cancheck_sqlite3_db
    @db.execute("insert into cans (date, nick, image) values (?, ?, ?)", date, nick, image)
  end
    
  def db_refresh(*)
    @db = SQLite3::Database.open @cancheck_sqlite3_db
    @cans = @db.execute("select * from cans order by id desc")
    template = File.read(@cancheck_html_template)
    render = ERB.new(template, 0, "", "@html").result(binding)
    File.open(@cancheck_html_output, "w+") do |f|
      f.write(render)
    end
  end

  match /#cancheck/, use_prefix: false
  def execute(m)
    begin
      can_url = detect_url(m.message)
      format_filename(m.user.nick, Time.now.strftime("%Y-%m-%d-%H%M%S"), @ext) 
      m.reply "üç∫   processing can..."
      tinify(@can_url)
      db_write(Time.now.strftime("%Y-%m-%d %I:%M%P"), m.user.nick, @image_on_s3.location)
      db_refresh
      m.reply "can processed. cheers üçª . | #{@cancheck_public_url}"
    rescue NoUrlError  
      m.reply "#{m.user.nick}: no cancheck image detected"
    rescue ExtError
      m.reply "#{m.user.nick}: image must be a .jpg or .png"
    rescue Tinify::ClientError
      m.reply "#{m.user.nick}: provided link not a valid .jpg or .png"
    end
  end
  
  # Include a way to refresh the database and regenerate the output html from
  # the channel. Uses standard ! prefix
  match "candb_refresh", method: :db_refresh

end
